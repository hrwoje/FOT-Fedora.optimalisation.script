#!/bin/bash

# --- Configuration ---
LOG_FILE="/var/log/fedora_optimization.log"
DNF_FLAGS="-y"
KEEP_KERNELS=2
MINICONDA_INSTALL_DIR_SUFFIX="miniconda3"
AUTHOR="H Dabo" # Author name
MESA_GIT_COPR="gloriouseggroll/mesa-git" # !! EXAMPLE COPR - USER MUST VERIFY/ADJUST !!

# --- Color Definitions (ANSI Escape Codes) ---
COLOR_RESET='\033[0m'; COLOR_RED='\033[0;31m'; COLOR_GREEN='\033[0;32m'; COLOR_YELLOW='\033[0;33m'; COLOR_BLUE='\033[0;34m'; COLOR_MAGENTA='\033[0;35m'; COLOR_CYAN='\033[0;36m'; COLOR_WHITE='\033[0;37m'; COLOR_BOLD_WHITE='\033[1;37m'; COLOR_BOLD_BLUE='\033[1;34m'; COLOR_BOLD_YELLOW='\033[1;33m'; COLOR_BOLD_CYAN='\033[1;36m'; COLOR_BOLD_RED='\033[1;31m';
COLOR_BORDER="${COLOR_BLUE}"; COLOR_TITLE="${COLOR_BOLD_WHITE}"; COLOR_SECTION_HEADER="${COLOR_CYAN}"; COLOR_OPTION_NUMBER="${COLOR_YELLOW}"; COLOR_OPTION_TEXT="${COLOR_WHITE}"; COLOR_PROMPT="${COLOR_BOLD_CYAN}"

# --- Helper Functions ---
# Function for colored status messages (outside the menu)
print_message() { local type="$1" message="$2" color_code; case "$type" in info) color_code=$COLOR_BLUE;; success) color_code=$COLOR_GREEN;; warning) color_code=$COLOR_YELLOW;; error) color_code=$COLOR_RED;; *) color_code=$COLOR_RESET;; esac; echo -e "${color_code}[${type^^}] ${message}${COLOR_RESET}"; }
# Function to log actions
log_action() { local func="$2" action="$1" status="${3:-Executed}"; echo "$(date '+%Y-%m-%d %H:%M:%S') - [$func] $action - Status: $status" | sudo tee -a "$LOG_FILE" > /dev/null; }
# Enhanced error logging function
log_and_error() { local func="$1" message="$2"; print_message error "$message"; log_action "$message" "$func" "Failed"; }
# Function to check if running as root
check_root() { if [[ $EUID -ne 0 ]]; then print_message error "This script must be run as root (or with sudo)."; exit 1; fi; sudo touch "$LOG_FILE" || { print_message error "Could not create log file: $LOG_FILE"; exit 1; }; sudo chmod 640 "$LOG_FILE"; }
# Function to ask for confirmation
ask_confirmation() { local message="${1:-Are you sure you want to continue?}"; echo -e "${COLOR_PROMPT}${message} [y/N]: ${COLOR_RESET}\c"; read response; if [[ ! "$response" =~ ^[yY](es)?$ ]]; then print_message warning "Action cancelled by user."; return 1; fi; return 0; }
# Function to check if GNOME is the active desktop
is_gnome_desktop() { if [[ "$XDG_CURRENT_DESKTOP" == *"GNOME"* ]] || [[ "$GDMSESSION" == *"gnome"* ]]; then return 0; else if ps -e | grep -q -E 'gnome-session|gnome-shell'; then return 0; fi; fi; return 1; }
# Function to run gsettings as the target user
run_gsettings_as_user() { local user="${SUDO_USER:-$(whoami)}" schema="$1" key="$2" value="$3"; local runtime_dir; runtime_dir=$(sudo -u "$user" printenv XDG_RUNTIME_DIR); if [[ -z "$runtime_dir" ]] || [[ ! -e "${runtime_dir}/bus" ]]; then print_message warning "Could not find active D-Bus session for user '$user'. Cannot run gsettings."; return 1; fi; if sudo -u "$user" DBUS_SESSION_BUS_ADDRESS="unix:path=${runtime_dir}/bus" gsettings set "$schema" "$key" "$value"; then return 0; else print_message error "Could not execute gsettings: set $schema $key $value"; return 1; fi; }

# --- Menu Drawing Functions ---
draw_line() { local l="$1" m="$2" r="$3"; local w; w=$(tput cols 2>/dev/null || echo 80); [[ $w -lt 40 ]] && w=40; local line=""; line+="${l}"; for (( i=1; i<w-1; i++ )); do line+="${m}"; done; line+="${r}"; echo -e "${COLOR_BORDER}${line}${COLOR_RESET}"; }
print_header() { local t="$1"; local w; w=$(tput cols 2>/dev/null || echo 80); [[ $w -lt 40 ]] && w=40; local tl=${#t}; local p=$(( (w-tl-2)/2 )); local ps; printf -v ps '%*s' "$p" ''; draw_line "╭" "─" "╮"; echo -e "${COLOR_BORDER}│${COLOR_TITLE}${ps}${t}${ps}${COLOR_BORDER}${COLOR_RESET}\c"; if (( (w-tl-2)%2 != 0 )); then echo -e " \c"; fi; echo -e "│${COLOR_RESET}"; draw_line "├" "─" "┤"; }
print_menu_item() { local n="$1" d="$2"; local w; w=$(tput cols 2>/dev/null || echo 80); [[ $w -lt 40 ]] && w=40; local dw=$(( w-2-7 )); if (( ${#d} > dw )); then d="${d:0:$((dw-3))}..."; fi; printf "${COLOR_BORDER}│ ${COLOR_OPTION_NUMBER}[%3s]${COLOR_RESET} ${COLOR_OPTION_TEXT}%-${dw}s ${COLOR_BORDER}│${COLOR_RESET}\n" "$n" "$d"; }
print_section_header() { local h="$1"; local w; w=$(tput cols 2>/dev/null || echo 80); [[ $w -lt 40 ]] && w=40; local hl=${#h}; local p=$(( (w-hl-4)/2 )); local ps; printf -v ps '%*s' "$p" ''; echo -e "${COLOR_BORDER}│${ps}${COLOR_SECTION_HEADER} ${h} ${ps}${COLOR_BORDER}${COLOR_RESET}\c"; if (( (w-hl-4)%2 != 0 )); then echo -e " \c"; fi; echo -e "│${COLOR_RESET}"; }
print_separator() { draw_line "├" "─" "┤"; }
print_footer() { local w; w=$(tput cols 2>/dev/null || echo 80); [[ $w -lt 40 ]] && w=40; local author_text="Author: ${AUTHOR}"; local al=${#author_text}; local p=$(( (w-al-2)/2 )); local ps; printf -v ps '%*s' "$p" ''; draw_line "├" "─" "┤"; echo -e "${COLOR_BORDER}│${ps}${COLOR_CYAN}${author_text}${ps}${COLOR_BORDER}${COLOR_RESET}\c"; if (( (w-al-2)%2 != 0 )); then echo -e " \c"; fi; echo -e "│${COLOR_RESET}"; draw_line "╰" "─" "╯"; }


# --- Optimization Functions (1 to 32) ---

# 1. System Update & Essential Packages
update_system() { local FUNC_NAME="update_system"; print_message info "Updating system & installing essential tools..."; if ! sudo dnf ${DNF_FLAGS} update; then log_and_error "$FUNC_NAME" "Error during 'dnf update'."; return 1; fi; log_action "System update" "$FUNC_NAME"; if ! sudo dnf ${DNF_FLAGS} install dnf-plugins-core fedora-workstation-repositories util-linux-user curl wget unzip p7zip vim nano ncdu cabextract git; then log_and_error "$FUNC_NAME" "Error installing essential packages."; return 1; fi; print_message success "System and essential packages updated/installed."; log_action "Essential packages installation" "$FUNC_NAME"; return 0; }

# 2. RPM Fusion Repositories
enable_rpmfusion() { local FUNC_NAME="enable_rpmfusion"; print_message info "Enabling RPM Fusion repositories (free and nonfree)..."; local rpmf_free=0; local rpmf_nonfree=0; local repo_changed=0; if ! dnf repolist | grep -q "rpmfusion-free-updates"; then if sudo dnf ${DNF_FLAGS} install "https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm"; then rpmf_free=1; repo_changed=1; log_action "RPM Fusion Free installed" "$FUNC_NAME"; else log_and_error "$FUNC_NAME" "Could not install RPM Fusion Free repository."; return 1; fi; else print_message info "RPM Fusion Free repository already enabled."; rpmf_free=1; fi; if ! dnf repolist | grep -q "rpmfusion-nonfree-updates"; then if sudo dnf ${DNF_FLAGS} install "https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm"; then rpmf_nonfree=1; repo_changed=1; log_action "RPM Fusion Nonfree installed" "$FUNC_NAME"; else print_message warning "Could not install RPM Fusion Nonfree repository."; log_action "RPM Fusion Nonfree installation" "$FUNC_NAME" "Failed (Warning)"; fi; else print_message info "RPM Fusion Nonfree repository already enabled."; rpmf_nonfree=1; fi; if [[ "$repo_changed" -eq 1 ]]; then print_message info "Updating DNF metadata..."; if ! sudo dnf makecache ${DNF_FLAGS}; then print_message warning "Could not fully refresh DNF cache."; log_action "DNF makecache" "$FUNC_NAME" "Failed (Warning)"; fi; sudo dnf groupupdate core ${DNF_FLAGS} >/dev/null 2>&1; fi; print_message success "RPM Fusion repositories checked/enabled."; if [[ "$rpmf_nonfree" -eq 0 ]]; then print_message warning "RPM Fusion Nonfree is not active. NVIDIA drivers or MS Fonts will not be available."; fi; return 0; }

# 3. Multimedia Codecs & Hardware Acceleration Drivers
install_codecs() { local FUNC_NAME="install_codecs"; print_message info "Installing multimedia codecs (audio/video/image) and VA drivers..."; local rpmf_free_active=0; if dnf repolist | grep -q "rpmfusion-free-updates"; then rpmf_free_active=1; else print_message warning "RPM Fusion Free not active. Skipping extra codecs (*-freeworld)."; fi; local pkgs="gstreamer1-plugins-base gstreamer1-plugins-good gstreamer1-plugins-ugly gstreamer1-plugins-bad-free gstreamer1-libav lame\* intel-media-driver libheif mesa-dri-drivers mesa-vulkan-drivers mesa-libGLU"; if [[ "$rpmf_free_active" -eq 1 ]]; then print_message info "Adding *-freeworld packages..."; pkgs="$pkgs gstreamer1-plugins-bad-freeworld mesa-va-drivers-freeworld libheif-freeworld"; fi; print_message info "Installing/updating specific codec packages..."; if ! sudo dnf ${DNF_FLAGS} install $pkgs --allowerasing; then log_and_error "$FUNC_NAME" "Error installing multimedia codecs."; return 1; fi; print_message success "Multimedia codecs and VA-API drivers installed/updated."; log_action "Codecs/VA-API installation (specific pkgs)" "$FUNC_NAME"; return 0; }

# 4. Printer Support & Quality Info
install_printer_support() { local FUNC_NAME="install_printer_support"; print_message info "Installing printer support (CUPS, drivers, color management)..."; local pkgs="cups system-config-printer gutenprint gutenprint-cups cups-filters foomatic-db* hplip libsane-hpaio colord"; if ! sudo dnf ${DNF_FLAGS} install $pkgs; then log_and_error "$FUNC_NAME" "Error installing printer support packages."; return 1; fi; log_action "Printer packages installed" "$FUNC_NAME"; local cups_restarted=0; if ! systemctl is-enabled cups.service > /dev/null 2>&1; then if ! sudo systemctl enable --now cups.service; then log_and_error "$FUNC_NAME" "Could not enable/start CUPS service."; else print_message success "CUPS service enabled and started."; log_action "CUPS service enabled/started" "$FUNC_NAME"; cups_restarted=1; fi; else print_message info "CUPS service already enabled."; if ! sudo systemctl restart cups.service; then log_and_error "$FUNC_NAME" "Could not restart CUPS service."; else log_action "CUPS service restarted" "$FUNC_NAME"; cups_restarted=1; fi; fi; if command -v firewall-cmd > /dev/null 2>&1 && systemctl is-active firewalld > /dev/null 2>&1; then sudo firewall-cmd --permanent --add-service=ipp > /dev/null 2>&1; sudo firewall-cmd --permanent --add-service=mdns > /dev/null 2>&1; sudo firewall-cmd --permanent --add-service=sane > /dev/null 2>&1; log_action "Firewall rules added (ipp, mdns, sane)" "$FUNC_NAME"; fi; print_message success "Basic printer support installed."; print_message info "*** Important for Print Quality ***"; print_message info " Check Print Dialog (Resolution, Quality, Media Type). Use system-config-printer."; print_message info " For color management: install/select ICC profiles."; log_action "Print quality info displayed" "$FUNC_NAME"; [[ $cups_restarted -eq 1 ]] && return 0 || return 1; }

# 5. HDR Support Info & Wayland Check
check_hdr_support() { local FUNC_NAME="check_hdr_support"; print_message info "HDR Support Info & Wayland Check"; print_message info "Requires: HDR Screen, GPU, Drivers, *Wayland Session*, DE."; print_message info "Check Display Settings for HDR option."; local session_type="${XDG_SESSION_TYPE:-Unset}"; print_message info "Current session type (XDG_SESSION_TYPE): $session_type"; if [[ "$session_type" == "wayland" ]]; then print_message success "Wayland session active."; log_action "HDR Check (Wayland: Active)" "$FUNC_NAME"; elif [[ "$session_type" == "x11" ]]; then print_message error "X11 session active! Wayland is needed for good HDR support."; log_action "HDR Check (Wayland: NOT Active - X11)" "$FUNC_NAME"; else print_message warning "Session type unknown/not Wayland ($session_type). HDR likely suboptimal."; log_action "HDR Check (Wayland: Unknown/Not Wayland - $session_type)" "$FUNC_NAME"; fi; return 0; }

# 6. SSD Optimization (TRIM)
optimize_ssd() { local FUNC_NAME="optimize_ssd"; print_message info "SSD optimization (fstrim timer)..."; if ! systemctl list-unit-files | grep -q fstrim.timer; then log_and_error "$FUNC_NAME" "fstrim.timer unit not found."; return 1; fi; if ! systemctl is-enabled fstrim.timer > /dev/null 2>&1; then if ! sudo systemctl enable --now fstrim.timer; then log_and_error "$FUNC_NAME" "Could not enable/start fstrim.timer."; return 1; fi; print_message success "fstrim.timer enabled and started."; log_action "fstrim.timer enabled" "$FUNC_NAME"; else print_message info "fstrim.timer already enabled."; log_action "fstrim.timer already active checked" "$FUNC_NAME"; fi; return 0; }

# 7. Network Optimization (TCP BBR + fq_codel)
optimize_network() { local FUNC_NAME="optimize_network"; print_message info "Network optimization (TCP BBR and fq_codel)..."; local sysctl_conf="/etc/sysctl.d/99-network-optimize.conf"; local apply_bbr=0; if sudo sysctl net.ipv4.tcp_available_congestion_control | grep -q "bbr"; then apply_bbr=1; else print_message warning "TCP BBR module not available. Skipping BBR."; log_action "BBR not available" "$FUNC_NAME"; fi; local changes_made=0; local write_ok=1; if ! grep -Fxq "net.core.default_qdisc=fq_codel" "$sysctl_conf" 2>/dev/null; then print_message info "Setting: net.core.default_qdisc=fq_codel"; if ! echo "net.core.default_qdisc=fq_codel" | sudo tee -a "$sysctl_conf" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add fq_codel."; write_ok=0; else changes_made=1; fi; else print_message info "net.core.default_qdisc=fq_codel already set."; fi; if [[ $apply_bbr -eq 1 ]] && ! grep -Fxq "net.ipv4.tcp_congestion_control=bbr" "$sysctl_conf" 2>/dev/null; then print_message info "Setting: net.ipv4.tcp_congestion_control=bbr"; if ! echo "net.ipv4.tcp_congestion_control=bbr" | sudo tee -a "$sysctl_conf" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add bbr."; write_ok=0; else changes_made=1; fi; else if [[ $apply_bbr -eq 1 ]]; then print_message info "net.ipv4.tcp_congestion_control=bbr already set."; fi; fi; if [[ $write_ok -eq 0 ]]; then return 1; fi; if [[ $changes_made -eq 1 ]]; then print_message info "Applying network sysctl settings..."; if ! sudo sysctl -p "$sysctl_conf"; then log_and_error "$FUNC_NAME" "Error applying sysctl."; return 1; fi; print_message success "Network settings applied/updated."; log_action "Network sysctl applied/updated" "$FUNC_NAME"; else print_message info "Network optimizations seem already present."; sudo sysctl -p "$sysctl_conf" > /dev/null 2>&1; log_action "Network sysctl already present" "$FUNC_NAME"; fi; return 0; }

# 8. Driver & Firmware Management
update_drivers_firmware() { local FUNC_NAME="update_drivers_firmware"; print_message info "Checking for driver and firmware updates..."; print_message info "Ensuring system is up-to-date..."; if ! sudo dnf ${DNF_FLAGS} update; then log_and_error "$FUNC_NAME" "DNF update failed"; return 1; fi; log_action "System update for drivers/fw" "$FUNC_NAME"; print_message info "Checking firmware with fwupd..."; if ! command -v fwupdmgr > /dev/null 2>&1; then print_message warning "fwupdmgr not found. Installing..."; if ! sudo dnf ${DNF_FLAGS} install fwupd; then log_and_error "$FUNC_NAME" "Failed to install fwupd"; return 1; fi; log_action "fwupd installed" "$FUNC_NAME"; fi; if ! sudo fwupdmgr refresh --force; then print_message warning "fwupdmgr refresh failed."; fi; local updates_available; updates_available=$(sudo fwupdmgr get-updates 2>/dev/null | grep -i 'upgrade available'); if [[ -n "$updates_available" ]]; then print_message warning "Firmware updates available!"; sudo fwupdmgr get-updates; if ask_confirmation "Install firmware updates now?"; then if ! sudo fwupdmgr update -y; then log_and_error "$FUNC_NAME" "Error installing firmware updates."; return 1; fi; print_message success "Firmware updates installed. Reboot may be needed."; log_action "Firmware update installed" "$FUNC_NAME"; else print_message info "Firmware update skipped."; log_action "Firmware update skipped" "$FUNC_NAME"; return 1; fi; elif sudo fwupdmgr get-devices 2>/dev/null | grep -q .; then print_message success "No firmware updates found via fwupd."; log_action "No firmware updates" "$FUNC_NAME"; else print_message info "No devices supported by fwupd found or no updates available."; log_action "No fwupd devices/updates" "$FUNC_NAME"; fi; print_message success "Driver and firmware check completed."; return 0; }

# 9. Automatic GPU Driver Installation
install_gpu_drivers() { local FUNC_NAME="install_gpu_drivers"; print_message info "Detecting GPU and installing/checking drivers..."; local GPU_VENDOR_LSPCI; GPU_VENDOR_LSPCI=$(lspci | grep -E 'VGA|3D' | head -n 1 | grep -o -E 'NVIDIA|AMD|Intel'); local result=0; case "$GPU_VENDOR_LSPCI" in "NVIDIA") print_message info "NVIDIA GPU detected."; if ! command -v nvidia-smi > /dev/null 2>&1; then print_message warning "NVIDIA drivers seem not installed."; if ! enable_rpmfusion; then log_and_error "$FUNC_NAME" "Could not enable RPM Fusion (required)."; return 1; fi; if ! dnf repolist | grep -q "rpmfusion-nonfree-updates"; then log_and_error "$FUNC_NAME" "RPM Fusion Nonfree required, but not active."; return 1; fi; print_message info "Attempting to install NVIDIA drivers (akmod)..."; if ! sudo dnf ${DNF_FLAGS} install akmod-nvidia xorg-x11-drv-nvidia-cuda; then log_and_error "$FUNC_NAME" "Error installing NVIDIA drivers."; result=1; else print_message success "NVIDIA drivers (akmod) installed."; print_message warning "Wait for kernel module build. REBOOT RECOMMENDED."; log_action "NVIDIA akmod installed" "$FUNC_NAME"; fi; else print_message success "NVIDIA drivers seem already installed."; log_action "NVIDIA already installed" "$FUNC_NAME"; fi ;; "AMD") print_message info "AMD GPU detected."; print_message success "Using open source AMDGPU drivers (kernel/Mesa)."; print_message info "Ensure Mesa/VA-API are up-to-date (options 1, 3, 8)."; log_action "AMD drivers checked" "$FUNC_NAME";; "Intel") print_message info "Intel GPU detected."; print_message success "Using open source Intel drivers (kernel/Mesa)."; print_message info "Ensure Mesa/intel-media-driver are up-to-date (options 1, 3, 8)."; log_action "Intel drivers checked" "$FUNC_NAME";; *) print_message warning "Could not reliably detect GPU vendor."; lspci | grep -E 'VGA|3D'; log_action "Unknown GPU" "$FUNC_NAME";; esac; return $result; }

# 10. DNS Optimization
optimize_dns() { local FUNC_NAME="optimize_dns"; print_message info "Optimizing DNS (Cloudflare + Google fallback) via NetworkManager..."; local nm_conf_dir="/etc/NetworkManager/conf.d"; local nm_conf_file="${nm_conf_dir}/99-custom-dns.conf"; if ! command -v nmcli > /dev/null 2>&1; then log_and_error "$FUNC_NAME" "NetworkManager (nmcli) not found."; return 1; fi; if grep -Eq "^\s*\[main\]" /etc/NetworkManager/NetworkManager.conf && grep -Eq "^\s*dns\s*=\s*none" /etc/NetworkManager/NetworkManager.conf; then print_message warning "NetworkManager not managing DNS (dns=none). Skipping."; log_action "NM dns=none, skipped" "$FUNC_NAME"; return 1; fi; print_message info "Setting DNS in $nm_conf_file..."; sudo mkdir -p "$nm_conf_dir"; if ! echo -e "[main]\ndns=1.1.1.1,1.0.0.1,8.8.8.8,8.8.4.4" | sudo tee "$nm_conf_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not write $nm_conf_file."; return 1; fi; print_message info "Reloading NetworkManager..."; if ! sudo systemctl reload NetworkManager; then log_and_error "$FUNC_NAME" "Error reloading NetworkManager."; return 1; fi; print_message success "DNS set via NetworkManager."; log_action "DNS set via NM" "$FUNC_NAME"; return 0; }

# 11. Install Handy Packages
install_extra_packages() { local FUNC_NAME="install_extra_packages"; print_message info "Installing handy extra packages (incl. btrfs-assistant)..."; local extra_pkgs="preload fuse-libs fuse-exfat fish btrfs-assistant"; if is_gnome_desktop; then extra_pkgs="$extra_pkgs gnome-tweaks"; print_message info "(GNOME detected, installing gnome-tweaks too)"; fi; if ! sudo dnf ${DNF_FLAGS} install $extra_pkgs; then log_and_error "$FUNC_NAME" "Error installing extra packages."; return 1; fi; local preload_ok=1; if command -v preload > /dev/null 2>&1; then if ! systemctl is-enabled preload.service > /dev/null 2>&1; then if ! sudo systemctl enable --now preload.service; then log_and_error "$FUNC_NAME" "Could not start/enable preload service."; preload_ok=0; else print_message success "Preload service enabled."; log_action "Preload enabled" "$FUNC_NAME"; fi; else print_message info "Preload service already enabled."; sudo systemctl restart preload.service; log_action "Preload restarted" "$FUNC_NAME"; fi; fi; if [[ $preload_ok -eq 1 ]]; then print_message success "Extra packages installed."; log_action "Extra packages installed" "$FUNC_NAME"; return 0; else return 1; fi; }

# 12. Set Fish as Default Shell
set_fish_shell() { local FUNC_NAME="set_fish_shell"; print_message info "Setting Fish shell as default..."; if ! command -v fish > /dev/null 2>&1; then log_and_error "$FUNC_NAME" "Fish shell not found (install via option 11)."; return 1; fi; local fish_path; fish_path=$(which fish); local current_user=${SUDO_USER:-$(whoami)}; local current_shell; current_shell=$(getent passwd "$current_user" | cut -d: -f7); if [[ "$current_shell" == "$fish_path" ]]; then print_message info "Fish already default shell for '$current_user'."; log_action "Already default shell" "$FUNC_NAME"; return 0; fi; if ! grep -Fxq "$fish_path" /etc/shells; then print_message info "Adding Fish to /etc/shells..."; if ! echo "$fish_path" | sudo tee -a /etc/shells > /dev/null; then log_and_error "$FUNC_NAME" "Could not modify /etc/shells."; return 1; fi; log_action "Added to /etc/shells" "$FUNC_NAME"; fi; print_message warning "Changing shell for user: $current_user"; if ! ask_confirmation "Set '$fish_path' as default shell for '$current_user'?"; then log_action "Shell change cancelled" "$FUNC_NAME"; return 1; fi; if ! sudo usermod -s "$fish_path" "$current_user"; then log_and_error "$FUNC_NAME" "Could not change shell for '$current_user'."; return 1; fi; print_message success "Fish set as default shell for '$current_user'. Log in again."; log_action "Shell set to Fish" "$FUNC_NAME"; return 0; }

# 13. Optimize Firewall
optimize_firewall() { local FUNC_NAME="optimize_firewall"; print_message info "Optimizing firewall (firewalld)..."; if ! command -v firewall-cmd > /dev/null 2>&1; then print_message info "firewalld not found. Installing..."; if ! sudo dnf ${DNF_FLAGS} install firewalld; then log_and_error "$FUNC_NAME" "Could not install firewalld."; return 1; fi; if ! sudo systemctl enable --now firewalld; then log_and_error "$FUNC_NAME" "Could not start/enable firewalld."; return 1; fi; log_action "firewalld installed" "$FUNC_NAME"; elif ! systemctl is-active firewalld > /dev/null 2>&1; then print_message warning "firewalld not active. Starting..."; if ! sudo systemctl start firewalld; then log_and_error "$FUNC_NAME" "Could not start firewalld."; return 1; fi; sudo systemctl enable firewalld; log_action "firewalld started" "$FUNC_NAME"; fi; local default_zone; default_zone=$(sudo firewall-cmd --get-default-zone); print_message info "Default zone: $default_zone"; print_message info "Adding/checking essential services (zone: $default_zone)..."; local services_to_add=("ssh" "dhcpv6-client" "mdns" "samba-client" "ipp" "ipp-client" "sane"); local added_count=0; local error_adding=0; for service in "${services_to_add[@]}"; do if ! sudo firewall-cmd --permanent --zone="$default_zone" --query-service="$service" > /dev/null 2>&1; then if ! sudo firewall-cmd --permanent --zone="$default_zone" --add-service="$service" > /dev/null 2>&1; then print_message error "Could not add service '$service'."; error_adding=1; else ((added_count++)); fi; fi; done; if [[ $error_adding -eq 1 ]]; then log_action "Error adding firewall services." "$FUNC_NAME" "Failed (Warning)"; fi; if [[ $added_count -gt 0 ]]; then print_message info "$added_count service(s) added to firewall."; log_action "$added_count services added" "$FUNC_NAME"; else print_message info "Required services already present in firewall."; log_action "Services already present" "$FUNC_NAME"; fi; print_message info "Checking server component ports (ADJUST COMMENTS IN SCRIPT IF NEEDED)..."; print_message info "Reloading firewall..."; if ! sudo firewall-cmd --reload; then log_and_error "$FUNC_NAME" "Error reloading firewall."; return 1; fi; print_message success "Firewall rules updated and reloaded."; log_action "Firewall reloaded" "$FUNC_NAME"; return 0; }

# 14. Optimize GNOME Desktop
optimize_gnome_desktop() { local FUNC_NAME="optimize_gnome_desktop"; print_message info "Optimizing GNOME Desktop..."; if ! is_gnome_desktop; then print_message warning "GNOME not detected. Skipping."; log_action "Not GNOME, skipped" "$FUNC_NAME"; return 1; fi; local result=0; print_message info "Ensure graphics drivers are up-to-date (Options 8 & 9)."; print_message info "Checking/installing GNOME Tweaks..."; if ! command -v gnome-tweaks > /dev/null 2>&1; then if ! sudo dnf ${DNF_FLAGS} install gnome-tweaks; then log_and_error "$FUNC_NAME" "Could not install GNOME Tweaks."; result=1; else log_action "GnomeTweaks installed" "$FUNC_NAME"; fi; else print_message info "GNOME Tweaks already installed."; log_action "GnomeTweaks already installed" "$FUNC_NAME"; fi; local current_animations_enabled; current_animations_enabled=$(GSETTINGS_BACKEND=dummy gsettings get org.gnome.desktop.interface enable-animations 2>/dev/null || echo "true"); print_message info "Optional: Disable animations (current: $current_animations_enabled)"; if [[ "$current_animations_enabled" == "true" ]]; then if ask_confirmation "Disable GNOME animations?"; then if ! run_gsettings_as_user "org.gnome.desktop.interface" "enable-animations" "false"; then log_and_error "$FUNC_NAME" "Could not disable animations."; result=1; else print_message success "GNOME animations disabled."; log_action "Animations disabled" "$FUNC_NAME"; fi; else log_action "Animations kept (cancelled)" "$FUNC_NAME"; result=1; fi; else print_message info "GNOME animations already disabled."; log_action "Animations already disabled" "$FUNC_NAME"; fi; [[ $result -eq 0 ]] && print_message success "GNOME optimization check completed."; return $result; }

# 15. Install Important Fonts
install_fonts() { local FUNC_NAME="install_fonts"; print_message info "Installing important fonts (MS Core, Noto, etc.)..."; local rpmf_nonfree_active=0; if dnf repolist | grep -q "rpmfusion-nonfree-updates"; then rpmf_nonfree_active=1; fi; local fonts_to_install="google-noto-fonts-all dejavu-sans-fonts dejavu-serif-fonts dejavu-sans-mono-fonts liberation-fonts fira-code-fonts"; if [[ "$rpmf_nonfree_active" -eq 1 ]]; then print_message info "Adding MS Core Fonts..."; fonts_to_install="$fonts_to_install mscore-fonts-all"; else print_message warning "RPM Fusion Nonfree not active. Skipping MS Core Fonts."; fi; if [[ "$rpmf_nonfree_active" -eq 1 ]] && ! command -v cabextract > /dev/null 2>&1; then print_message info "Installing 'cabextract' (required for MS fonts)..."; sudo dnf ${DNF_FLAGS} install cabextract || log_action "Cabextract installation failed" "$FUNC_NAME" "Failed (Warning)"; fi; print_message info "Installing font packages..."; if ! sudo dnf ${DNF_FLAGS} install $fonts_to_install; then log_and_error "$FUNC_NAME" "Error installing fonts."; return 1; fi; print_message success "Fonts installed."; print_message info "Updating font cache..."; sudo fc-cache -f -v > /dev/null; log_action "Fonts installed & fc-cache" "$FUNC_NAME"; print_message warning "NOTE: macOS/Android fonts (except Noto) NOT installed due to licensing."; return 0; }

# 16. Install Conda (Miniconda)
install_conda() { local FUNC_NAME="install_conda"; local target_user=${SUDO_USER:-$(whoami)}; local target_home; target_home=$(eval echo ~$target_user); local miniconda_path="${target_home}/${MINICONDA_INSTALL_DIR_SUFFIX}"; local miniconda_script="/tmp/miniconda_installer.sh"; print_message info "Installing Miniconda for user: $target_user in $miniconda_path"; if [[ -d "$miniconda_path" ]]; then print_message warning "Directory '$miniconda_path' already exists."; if ! ask_confirmation "Skip? (y=Yes, n=Try again)"; then log_action "Attempting reinstall despite existing dir" "$FUNC_NAME"; else log_action "Installation skipped, directory exists" "$FUNC_NAME"; return 1; fi; fi; if ! command -v curl > /dev/null 2>&1; then log_and_error "$FUNC_NAME" "'curl' not installed. Cannot download."; return 1; fi; print_message info "Downloading Miniconda installer..."; local miniconda_url="https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh"; if ! curl -sSL "$miniconda_url" -o "$miniconda_script"; then log_and_error "$FUNC_NAME" "Failed to download Miniconda installer."; rm -f "$miniconda_script"; return 1; fi; print_message info "Installing Miniconda (batch mode)..."; local install_success=0; if sudo -u "$target_user" bash "$miniconda_script" -b -p "$miniconda_path"; then install_success=1; print_message success "Miniconda installed in $miniconda_path"; local conda_bin="${miniconda_path}/bin/conda"; if [[ -x "$conda_bin" ]]; then print_message info "Running 'conda init' for bash, zsh, fish..."; sudo -u "$target_user" "$conda_bin" init bash > /dev/null 2>&1; sudo -u "$target_user" "$conda_bin" init zsh > /dev/null 2>&1; sudo -u "$target_user" "$conda_bin" init fish > /dev/null 2>&1; print_message info "Start a new shell to use Conda."; log_action "Miniconda installed & init" "$FUNC_NAME"; else print_message warning "Conda binary not found. Skipping 'conda init'."; log_action "Installed but init failed" "$FUNC_NAME"; fi; else log_and_error "$FUNC_NAME" "Miniconda installation script failed."; fi; rm -f "$miniconda_script"; [[ $install_success -eq 1 ]] && return 0 || return 1; }

# 17. Install Papirus Icons & Configure
install_papirus_icons() { local FUNC_NAME="install_papirus_icons"; print_message info "Installing Papirus Icon Theme and papirus-folders..."; print_message info "Installing papirus-icon-theme package..."; if ! sudo dnf ${DNF_FLAGS} install papirus-icon-theme; then log_and_error "$FUNC_NAME" "Could not install papirus-icon-theme package."; return 1; fi; log_action "papirus-icon-theme package installed" "$FUNC_NAME"; local papirus_folders_repo="https://github.com/PapirusDevelopmentTeam/papirus-folders.git"; local tmp_dir; tmp_dir=$(mktemp -d); print_message info "Cloning papirus-folders to $tmp_dir..."; if ! git clone --depth 1 "$papirus_folders_repo" "$tmp_dir"; then log_and_error "$FUNC_NAME" "Could not clone papirus-folders repository."; rm -rf "$tmp_dir"; return 1; fi; log_action "papirus-folders cloned" "$FUNC_NAME"; cd "$tmp_dir" || { log_and_error "$FUNC_NAME" "Could not change to $tmp_dir."; rm -rf "$tmp_dir"; return 1; }; print_message info "Running papirus-folders install.sh..."; if ! sudo ./install.sh; then log_and_error "$FUNC_NAME" "papirus-folders install.sh failed."; cd ..; rm -rf "$tmp_dir"; return 1; fi; log_action "papirus-folders install.sh executed" "$FUNC_NAME"; cd ..; rm -rf "$tmp_dir"; local target_user=${SUDO_USER:-$(whoami)}; print_message info "Applying color 'orange' for user '$target_user' (theme Papirus-Dark)..."; if ! command -v papirus-folders > /dev/null 2>&1; then print_message warning "Command 'papirus-folders' not found. Color not set."; log_action "papirus-folders command not found" "$FUNC_NAME" "Failed (Warning)"; else if ! sudo -u "$target_user" papirus-folders -C orange --theme Papirus-Dark; then print_message warning "Could not set papirus-folders color for '$target_user'."; log_action "papirus-folders color setting failed" "$FUNC_NAME" "Failed (Warning)"; else print_message success "Papirus folder color set to orange (for Papirus-Dark)."; print_message info "Manually select Papirus-Dark theme in Tweaks/Settings."; log_action "papirus-folders color set" "$FUNC_NAME"; fi; fi; return 0; }

# 18. Disable PC Speaker Beep
disable_pc_beep() { local FUNC_NAME="disable_pc_beep"; local conf_file="/etc/modprobe.d/nobeep.conf"; local rule="blacklist pcspkr"; print_message info "Disabling PC speaker beep..."; if grep -Fxq "$rule" "$conf_file" 2>/dev/null; then print_message info "PC speaker already seems disabled in $conf_file."; log_action "Already disabled" "$FUNC_NAME"; else print_message info "Adding rule '$rule' to $conf_file..."; if ! echo "$rule" | sudo tee "$conf_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not write to $conf_file."; return 1; fi; print_message success "PC speaker disabled. Effective after reboot or 'sudo modprobe -r pcspkr'."; log_action "Disabled via modprobe conf" "$FUNC_NAME"; fi; return 0; }

# 19. Disable Sleep/Suspend
disable_sleep_suspend() { local FUNC_NAME="disable_sleep_suspend"; print_message warning "*** DISABLE SLEEP/SUSPEND ***"; echo -e "${COLOR_BOLD_RED}WARNING:${COLOR_YELLOW} Prevents sleep/hibernate. Battery drain / data loss on power failure!"; echo -e "${COLOR_RESET}"; if ! ask_confirmation "Disable ALL sleep/suspend/hibernate functions?"; then log_action "Action cancelled by user" "$FUNC_NAME"; return 1; fi; print_message info "Masking sleep, suspend, hibernate, hybrid-sleep targets..."; local targets=("sleep.target" "suspend.target" "hibernate.target" "hybrid-sleep.target"); local masked_count=0; local error_count=0; for target in "${targets[@]}"; do if ! sudo systemctl mask "$target"; then if systemctl status "$target" 2>&1 | grep -q 'masked'; then print_message info "$target already masked."; else print_message error "Could not mask $target."; ((error_count++)); fi; else ((masked_count++)); fi; done; if [[ $error_count -eq 0 ]]; then print_message success "Sleep/suspend targets masked ($masked_count new)."; log_action "Sleep/suspend targets masked" "$FUNC_NAME"; return 0; else log_and_error "$FUNC_NAME" "$error_count target(s) could not be masked."; return 1; fi; }

# 20. Configure GNOME Idle Delay
configure_gnome_idle() { local FUNC_NAME="configure_gnome_idle"; print_message info "Configuring GNOME Idle Delay (screen off)..."; if ! is_gnome_desktop; then print_message warning "GNOME not detected. Skipping."; log_action "Not GNOME, skipped" "$FUNC_NAME"; return 1; fi; local idle_delay_seconds=1800; print_message info "Setting idle-delay to $idle_delay_seconds seconds ($((idle_delay_seconds/60)) minutes)."; if ! run_gsettings_as_user "org.gnome.desktop.session" "idle-delay" "$idle_delay_seconds"; then log_and_error "$FUNC_NAME" "Could not set idle-delay."; return 1; fi; print_message success "GNOME idle-delay set to $idle_delay_seconds seconds."; log_action "Idle delay set ($idle_delay_seconds s)" "$FUNC_NAME"; return 0; }

# 21. Grant Broad Flatpak Permissions (EXTREME RISK)
grant_flatpak_permissions() { local FUNC_NAME="grant_flatpak_permissions"; print_message error "*** GRANT BROAD FLATPAK PERMISSIONS ***"; echo -e "${COLOR_BOLD_RED}WARNING!!! ${COLOR_RED}This DESTROYS Flatpak security! Gives ALL user Flatpaks FULL system access!${COLOR_RESET}"; echo -e "${COLOR_PROMPT}Type exactly: ${COLOR_BOLD_WHITE}YES I UNDERSTAND THE RISK${COLOR_RESET}"; read -p ": " confirmation_text; if [[ "$confirmation_text" != "YES I UNDERSTAND THE RISK" ]]; then print_message warning "Confirmation incorrect. Action cancelled."; log_action "Action cancelled (incorrect confirmation)" "$FUNC_NAME"; return 1; fi; print_message warning "Are you ABSOLUTELY sure?"; if ! ask_confirmation; then log_action "Action cancelled (second confirmation)" "$FUNC_NAME"; return 1; fi; local target_user=${SUDO_USER:-$(whoami)}; print_message info "Attempting broad permissions for all user Flatpaks for '$target_user'..."; local app_count=0; local error_count=0; local apps; mapfile -t apps < <(sudo -u "$target_user" flatpak list --app --columns=application); if [[ ${#apps[@]} -eq 0 ]]; then print_message warning "No user Flatpaks found for '$target_user'."; log_action "No user flatpaks found" "$FUNC_NAME"; return 0; fi; for app in "${apps[@]}"; do ((app_count++)); print_message info "Overriding: $app"; if ! sudo -u "$target_user" flatpak override --user --filesystem=host --device=all --socket=wayland --socket=x11 --socket=pulseaudio --socket=system-bus --socket=session-bus --share=network "$app"; then print_message error "Could not apply override for $app"; ((error_count++)); fi; done; if [[ $error_count -eq 0 ]]; then print_message success "Broad permissions applied to $app_count Flatpak(s)."; print_message warning "Flatpak security is now severely compromised!"; log_action "Broad permissions applied ($app_count apps)" "$FUNC_NAME" "RISKY"; return 0; else log_and_error "$FUNC_NAME" "Error applying permissions to $error_count of $app_count apps."; return 1; fi; }

# 22. Force Wayland for Apps (Env Vars)
force_wayland_apps() { local FUNC_NAME="force_wayland_apps"; local env_file="/etc/environment"; print_message info "Forcing Wayland for Firefox and Qt apps via $env_file..."; local moz_var="export MOZ_ENABLE_WAYLAND=1"; local qt_var="export QT_QPA_PLATFORM=wayland"; local changes_made=0; local write_ok=1; if ! grep -Fxq "$moz_var" "$env_file" 2>/dev/null; then print_message info "Adding '$moz_var'..."; if ! echo "$moz_var" | sudo tee -a "$env_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add $moz_var."; write_ok=0; else ((changes_made++)); fi; else print_message info "MOZ_ENABLE_WAYLAND=1 already set."; fi; if ! grep -Fxq "$qt_var" "$env_file" 2>/dev/null; then print_message info "Adding '$qt_var'..."; if ! echo "$qt_var" | sudo tee -a "$env_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add $qt_var."; write_ok=0; else ((changes_made++)); fi; else print_message info "QT_QPA_PLATFORM=wayland already set."; fi; if [[ $write_ok -eq 0 ]]; then return 1; fi; if [[ $changes_made -gt 0 ]]; then print_message success "Wayland environment variables added/updated."; print_message warning "A REBOOT IS REQUIRED."; log_action "Wayland env vars added ($changes_made)" "$FUNC_NAME"; else print_message info "No changes needed for Wayland environment variables."; log_action "Wayland env vars already present" "$FUNC_NAME"; fi; return 0; }

# 23. Apply AMD GPU Performance Tweaks (Env Vars)
apply_amd_tweaks() { local FUNC_NAME="apply_amd_tweaks"; print_message info "Applying AMD GPU performance tweaks (RADV ACO)..."; local GPU_VENDOR_LSPCI; GPU_VENDOR_LSPCI=$(lspci | grep -E 'VGA|3D' | head -n 1 | grep -o -E 'NVIDIA|AMD|Intel'); if [[ "$GPU_VENDOR_LSPCI" != "AMD" ]]; then print_message warning "No AMD GPU detected. Skipping."; log_action "Not AMD GPU, skipped" "$FUNC_NAME"; return 1; fi; local env_file="/etc/environment"; local perf_var="export RADV_PERFTEST=aco"; local changes_made=0; if grep -Fxq "$perf_var" "$env_file" 2>/dev/null; then print_message info "RADV_PERFTEST=aco already set."; else print_message info "Adding '$perf_var'..."; if ! echo "$perf_var" | sudo tee -a "$env_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add $perf_var."; return 1; else ((changes_made++)); fi; fi; if [[ $changes_made -gt 0 ]]; then print_message success "AMD performance tweak (ACO) variable added."; print_message warning "A REBOOT IS REQUIRED."; log_action "AMD tweak env var added" "$FUNC_NAME"; else print_message info "No changes needed for AMD tweak variable."; log_action "AMD tweak env var already present" "$FUNC_NAME"; fi; return 0; }

# 24. Enable ZRAM
enable_zram() { local FUNC_NAME="enable_zram"; local conf_file="/etc/systemd/zram-generator.conf"; print_message info "Enabling ZRAM for faster swap..."; print_message info "Installing zram-generator package..."; if ! sudo dnf ${DNF_FLAGS} install zram-generator; then if rpm -q zram-generator > /dev/null 2>&1; then print_message info "zram-generator already installed."; log_action "zram-generator already installed" "$FUNC_NAME"; else log_and_error "$FUNC_NAME" "Could not install zram-generator."; return 1; fi; else log_action "zram-generator package installed" "$FUNC_NAME"; fi; if [[ -f "$conf_file" ]]; then print_message warning "Config file $conf_file already exists. NOT overwriting."; log_action "Config file exists, skipped" "$FUNC_NAME"; else print_message info "Creating $conf_file..."; local zram_config="[zram0]\nzram-size = ram / 2\ncompression-algorithm = zstd"; if ! echo -e "$zram_config" | sudo tee "$conf_file" > /dev/null; then log_and_error "$FUNC_NAME" "Could not create $conf_file."; return 1; fi; print_message success "$conf_file created."; log_action "Config file created" "$FUNC_NAME"; fi; print_message info "ZRAM configuration finished."; print_message warning "REBOOT or 'sudo systemctl restart systemd-zram-setup@zram0.service' needed."; log_action "ZRAM configuration finished, reboot needed" "$FUNC_NAME"; return 0; }

# 25. Attempt DNF/RPM Repair
repair_dnf_rpm() { local FUNC_NAME="repair_dnf_rpm"; print_message warning "*** Attempt DNF/RPM Repair ***"; print_message warning "Clears DNF cache & rebuilds RPM DB. Use if DNF fails."; if ! ask_confirmation "Clear DNF cache and rebuild RPM DB?"; then log_action "Repair cancelled" "$FUNC_NAME"; return 1; fi; local repair_ok=1; print_message info "1. Cleaning DNF cache..."; if ! sudo dnf clean all; then log_and_error "$FUNC_NAME" "Error during 'dnf clean all'."; repair_ok=0; else log_action "dnf clean all executed" "$FUNC_NAME"; fi; print_message info "2. Rebuilding RPM database..."; sudo rm -f /var/lib/rpm/__db*; if ! sudo rpm --rebuilddb; then log_and_error "$FUNC_NAME" "Error during 'rpm --rebuilddb'."; repair_ok=0; else log_action "rpm --rebuilddb executed" "$FUNC_NAME"; fi; print_message info "3. Regenerating DNF metadata..."; if ! sudo dnf makecache; then log_and_error "$FUNC_NAME" "Error during 'dnf makecache' after rebuild."; repair_ok=0; else log_action "dnf makecache after rebuild executed" "$FUNC_NAME"; fi; if [[ $repair_ok -eq 1 ]]; then print_message success "DNF/RPM repair attempt completed."; else print_message error "Errors occurred during repair attempt."; fi; return $repair_ok; }

# 26. Clean System
cleanup_system() { local FUNC_NAME="cleanup_system"; print_message info "Cleaning system..."; local cleanup_ok=1; print_message info "Cleaning DNF cache..."; sudo dnf clean all >/dev/null 2>&1; log_action "DNF cache cleaned" "$FUNC_NAME"; print_message info "Checking unused dependencies..."; local packages_to_autoremove; packages_to_autoremove=$(sudo dnf autoremove 2>/dev/null | grep -E '^Removing:|^Removing dependent packages:'); if [[ -n "$packages_to_autoremove" ]]; then echo "Proposed for removal (autoremove):"; echo "$packages_to_autoremove" | sed 's/^/  /'; if ask_confirmation "Proceed with autoremove?"; then if ! sudo dnf ${DNF_FLAGS} autoremove; then log_and_error "$FUNC_NAME" "Error during dnf autoremove."; cleanup_ok=0; else log_action "Autoremove executed" "$FUNC_NAME"; fi; else log_action "Autoremove cancelled" "$FUNC_NAME"; return 1; fi; else print_message info "No unused packages found for autoremove."; log_action "Autoremove no packages" "$FUNC_NAME"; fi; print_message info "Checking old kernels (keep last $KEEP_KERNELS)..."; local old_kernels; old_kernels=$(dnf repoquery --installonly --latest-limit=-${KEEP_KERNELS} -q); if [[ -n "$old_kernels" ]]; then print_message warning "Old kernels proposed for removal:"; echo "$old_kernels" | sed 's/^/  /'; if ask_confirmation "Remove old kernels?"; then if ! sudo dnf ${DNF_FLAGS} remove $old_kernels; then log_and_error "$FUNC_NAME" "Error removing old kernels."; cleanup_ok=0; else log_action "Old kernels removed" "$FUNC_NAME"; fi; else log_action "Kernel removal cancelled" "$FUNC_NAME"; return 1; fi; else print_message info "No old kernels found to remove."; log_action "No old kernels" "$FUNC_NAME"; fi; print_message info "Cleaning journal logs (~100MB)..."; if ! sudo journalctl --vacuum-size=100M; then print_message warning "Could not clean journal logs."; log_action "Journal vacuum failed" "$FUNC_NAME" "Failed (Warning)"; else log_action "Journal logs vacuumed" "$FUNC_NAME"; fi; if [[ $cleanup_ok -eq 1 ]]; then print_message success "System cleanup completed."; else print_message error "Errors occurred during cleanup."; fi; return $cleanup_ok; }

# 27. Manage Google Chrome
manage_google_chrome() { local FUNC_NAME="manage_google_chrome"; local target_user=${SUDO_USER:-$(whoami)}; local chrome_pkg="google-chrome-stable"; local chrome_repo_url="https://dl.google.com/linux/chrome/rpm/stable/x86_64"; local chrome_gpg_key="https://dl.google.com/linux/linux_signing_key.pub"; local chrome_repo_name="google-chrome"; print_message info "Manage Google Chrome..."; local result=0; if rpm -q "$chrome_pkg" > /dev/null 2>&1; then print_message success "Google Chrome ($chrome_pkg) is installed."; log_action "Chrome installed check" "$FUNC_NAME"; if ask_confirmation "Optimize for Wayland/performance?"; then local desktop_file_system="/usr/share/applications/google-chrome.desktop"; local target_home; target_home=$(eval echo ~$target_user); local desktop_file_user_dir="${target_home}/.local/share/applications"; local desktop_file_user="${desktop_file_user_dir}/google-chrome.desktop"; print_message info "Copying system .desktop to $desktop_file_user..."; sudo -u "$target_user" mkdir -p "$desktop_file_user_dir"; if ! sudo -u "$target_user" cp "$desktop_file_system" "$desktop_file_user"; then log_and_error "$FUNC_NAME" "Could not copy $desktop_file_system."; result=1; else log_action "User desktop file copied" "$FUNC_NAME"; local chrome_flags=" --enable-features=UseOzonePlatform --ozone-platform=wayland"; print_message info "Adding Wayland flags to $desktop_file_user..."; if ! sudo -u "$target_user" sed -i -E "s|^(Exec=.*google-chrome-stable)(.*)$|\1${chrome_flags}\2|g" "$desktop_file_user"; then log_and_error "$FUNC_NAME" "Could not add flags to $desktop_file_user."; result=1; else print_message success "Flags added to user .desktop file."; log_action "Chrome flags added ($chrome_flags)" "$FUNC_NAME"; print_message info "Updating user desktop database..."; sudo -u "$target_user" update-desktop-database "$desktop_file_user_dir" > /dev/null 2>&1; print_message info "Chrome optimization finished. Restart Chrome."; fi; fi; else log_action "Chrome optimization skipped" "$FUNC_NAME"; result=1; fi; else print_message warning "Google Chrome ($chrome_pkg) is NOT installed."; log_action "Chrome not installed check" "$FUNC_NAME"; if ask_confirmation "Install Google Chrome now (adds Google repo)?"; then print_message info "Adding Google Chrome repository..."; if sudo dnf config-manager --add-repo "$chrome_repo_url" > /dev/null 2>&1 && sudo rpm --import "$chrome_gpg_key"; then print_message success "Google Chrome repository added."; log_action "Google Chrome repo added" "$FUNC_NAME"; print_message info "Installing $chrome_pkg..."; if sudo dnf install ${DNF_FLAGS} "$chrome_pkg"; then print_message success "$chrome_pkg installed."; log_action "Chrome installed" "$FUNC_NAME"; manage_google_chrome; result=$?; else log_and_error "$FUNC_NAME" "Could not install $chrome_pkg."; result=1; fi; else log_and_error "$FUNC_NAME" "Could not add Google Chrome repository."; result=1; fi; else log_action "Chrome installation skipped" "$FUNC_NAME"; result=1; fi; fi; return $result; }

# 28. Configure DNF Max Parallel Downloads
configure_dnf_downloads() { local FUNC_NAME="configure_dnf_downloads"; local dnf_conf="/etc/dnf/dnf.conf"; local target_value=6; local setting="max_parallel_downloads"; print_message info "Adjusting DNF max_parallel_downloads to $target_value..."; if [[ ! -f "$dnf_conf" ]]; then print_message warning "$dnf_conf not found. Creating..."; if ! echo "[main]" | sudo tee "$dnf_conf" > /dev/null; then log_and_error "$FUNC_NAME" "Could not create $dnf_conf"; return 1; fi; fi; if ! grep -q "\[main\]" "$dnf_conf"; then print_message info "[main] section not found. Adding..."; if ! echo -e "\n[main]" | sudo tee -a "$dnf_conf" > /dev/null; then log_and_error "$FUNC_NAME" "Could not add [main] section."; return 1; fi; fi; if grep -Eq "^\s*${setting}\s*=\s*${target_value}\s*$" "$dnf_conf"; then print_message info "$setting already set to $target_value."; log_action "$setting already correct ($target_value)" "$FUNC_NAME"; return 0; fi; if ! sudo awk -v s="$setting" 'BEGIN { m=0 } /\[main\]/ { m=1; print; next } /\[.*\]/ { m=0 } m && $1 == s { next } { print }' "$dnf_conf" > /tmp/dnf.conf.tmp || ! sudo mv /tmp/dnf.conf.tmp "$dnf_conf"; then log_and_error "$FUNC_NAME" "Could not modify $dnf_conf (remove old rule)."; rm -f /tmp/dnf.conf.tmp; return 1; fi; log_action "Old $setting removed (if present)" "$FUNC_NAME"; print_message info "Setting $setting=$target_value..."; if ! sudo sed -i "/\[main\]/a ${setting}=${target_value}" "$dnf_conf"; then log_and_error "$FUNC_NAME" "Could not set $setting=$target_value."; return 1; fi; print_message success "DNF $setting set to $target_value."; log_action "$setting set to $target_value" "$FUNC_NAME"; return 0; }

# 29. Configure Mutter Check-Alive Timeout
configure_mutter_timeout() { local FUNC_NAME="configure_mutter_timeout"; local timeout_ms=30000; local schema="org.gnome.mutter"; local key="check-alive-timeout"; print_message info "Adjusting Mutter check-alive-timeout to ${timeout_ms}ms..."; if ! is_gnome_desktop; then print_message warning "GNOME not detected. Skipping."; log_action "Not GNOME, skipped" "$FUNC_NAME"; return 1; fi; if ! run_gsettings_as_user "$schema" "$key" "$timeout_ms"; then log_and_error "$FUNC_NAME" "Could not set $key."; return 1; fi; print_message success "Mutter $key set to $timeout_ms ms."; print_message info "Change is effective immediately."; log_action "$key set ($timeout_ms ms)" "$FUNC_NAME"; return 0; }

# 30. Enable Wayland Fractional Scaling
enable_wayland_fractional_scaling() { local FUNC_NAME="enable_wayland_fractional_scaling"; local schema="org.gnome.mutter"; local key="experimental-features"; local value="['scale-monitor-framebuffer']"; print_message info "Enabling Wayland fractional scaling (experimental)..."; if ! is_gnome_desktop; then print_message warning "GNOME not detected. Skipping."; log_action "Not GNOME, skipped" "$FUNC_NAME"; return 1; fi; if ! run_gsettings_as_user "$schema" "$key" "$value"; then log_and_error "$FUNC_NAME" "Could not set $key."; return 1; fi; print_message success "Mutter $key set."; print_message info "Restart GNOME Shell (Alt+F2, r, Enter) or re-login."; print_message warning "X11 fractional scaling requires patched Mutter (see option 32)."; log_action "$key set ($value)" "$FUNC_NAME"; return 0; }

# 31. Install Mesa-git Vulkan Drivers (RISKY)
install_mesa_git() { local FUNC_NAME="install_mesa_git"; print_message error "*** Install Mesa-git Vulkan Drivers (EXPERIMENTAL & RISKY) ***"; echo -e "${COLOR_BOLD_RED}WARNING!!! ${COLOR_YELLOW}Replaces stable drivers! Requires external COPR (${COLOR_CYAN}${MESA_GIT_COPR}${COLOR_YELLOW}). ${COLOR_BOLD_RED}VERIFY COPR!${COLOR_YELLOW} May break system! Revert: 'sudo dnf distro-sync'."; echo -e "${COLOR_RESET}"; if ! ask_confirmation "ABSOLUTELY sure install Mesa-git via COPR ${MESA_GIT_COPR}?"; then log_action "Action cancelled by user" "$FUNC_NAME"; return 1; fi; print_message info "Enabling COPR: ${MESA_GIT_COPR}..."; if ! sudo dnf copr enable -y "${MESA_GIT_COPR}"; then log_and_error "$FUNC_NAME" "Could not enable COPR ${MESA_GIT_COPR}."; return 1; fi; log_action "COPR ${MESA_GIT_COPR} enabled" "$FUNC_NAME"; local stable_pkg="mesa-vulkan-drivers"; local git_pkg="mesa-vulkan-drivers"; if dnf list available --enablerepo="copr:copr.fedorainfracloud.org:${MESA_GIT_COPR}" | grep -q "mesa-vulkan-drivers-git"; then git_pkg="mesa-vulkan-drivers-git"; fi; local dnf_cmd_success=0; if [[ "$stable_pkg" == "$git_pkg" ]]; then print_message info "COPR seems to replace $stable_pkg directly. Running 'dnf update'..."; if sudo dnf update -y --enablerepo="copr:copr.fedorainfracloud.org:${MESA_GIT_COPR}" --refresh --best --allowerasing; then print_message success "Mesa Vulkan drivers updated from COPR."; log_action "Mesa Vulkan drivers updated from COPR" "$FUNC_NAME" "RISKY"; dnf_cmd_success=1; else log_and_error "$FUNC_NAME" "Could not update Mesa Vulkan drivers from COPR."; fi; else print_message info "Swapping $stable_pkg with $git_pkg..."; if sudo dnf swap -y "$stable_pkg" "$git_pkg" --enablerepo="copr:copr.fedorainfracloud.org:${MESA_GIT_COPR}" --best --allowerasing; then print_message success "Mesa Vulkan drivers swapped with $git_pkg."; log_action "Mesa Vulkan drivers swapped with $git_pkg" "$FUNC_NAME" "RISKY"; dnf_cmd_success=1; else log_and_error "$FUNC_NAME" "Could not swap $stable_pkg for $git_pkg."; fi; fi; if [[ $dnf_cmd_success -eq 1 ]]; then print_message warning "Mesa-git Vulkan drivers installed. ${COLOR_BOLD_RED}REBOOT REQUIRED!${COLOR_RESET}"; print_message warning "Revert via 'sudo dnf distro-sync' (after disabling COPR)."; return 0; else print_message warning "Installation/Update failed. Try disabling COPR and 'sudo dnf distro-sync'."; return 1; fi; }

# 32. Info about Patched Components
info_patched_components() { local FUNC_NAME="info_patched_components"; print_message info "*** Information about Patched System Components ***"; echo -e "${COLOR_YELLOW}Mutter VRR, Mutter X11 Frac. Scaling, Shell Ext. Update, XWayland FPS Fix require patched components."; echo -e "${COLOR_BOLD_RED}This script does NOT apply these patches (too risky/complex).${COLOR_RESET}"; echo -e "${COLOR_YELLOW}Options:${COLOR_WHITE} Find reliable COPRs, use a distro with patches (e.g., Nobara), or build yourself."; log_action "Info displayed about patched components" "$FUNC_NAME"; return 0; }


# --- Menu Functions ---
show_system_info() { print_message info "--- System Information ---"; echo "Hostname: $(hostnamectl hostname)"; echo "OS: $(hostnamectl status | grep 'Operating System' | cut -d: -f2- | xargs)"; echo "Kernel: $(uname -r)"; if [ -f /etc/os-release ]; then echo "OS Details:"; cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2- | sed 's/"//g; s/^/  /'; fi; local session_type="${XDG_SESSION_TYPE:-N/A}"; local de="${XDG_CURRENT_DESKTOP:-N/A}"; echo "Desktop Environment: $de"; echo "Session Type: $session_type"; echo "Uptime: $(uptime -p)"; echo "--- Hardware ---"; echo "CPU: $(lscpu | grep 'Model name:' | cut -d: -f2- | xargs)"; echo "RAM: $(free -h | grep Mem | awk '{print $2}')"; echo "GPU:"; lspci -k | grep -A 3 -E 'VGA|3D' | sed 's/^/  /'; echo "Disk Usage:"; df -hT -x tmpfs -x devtmpfs -x squashfs | sed '1 s/^/  /; 2,\$ s/^/  /'; echo "--- Network ---"; echo "IP Addresses:"; ip -4 a | grep 'inet ' | grep -v '127.0.0.1' | awk '{print "  "$2}'; echo "DNS (NM):"; if command -v nmcli > /dev/null 2>&1; then nmcli dev show | grep IP4.DNS | sed 's/^/  /' || echo "  (Could not fetch NM DNS)"; else echo "  (nmcli not found)"; fi; echo "--- Firewall (firewalld) ---"; if command -v firewall-cmd > /dev/null 2>&1 && systemctl is-active firewalld > /dev/null 2>&1; then local default_zone=$(sudo firewall-cmd --get-default-zone); echo "Status: Active, Zone: $default_zone"; echo "Permanent Rules ($default_zone):"; sudo firewall-cmd --list-all --zone="$default_zone" --permanent | sed 's/^/  /'; else echo "Status: Inactive/Not installed"; fi; echo "--- SSD TRIM ---"; if systemctl is-enabled fstrim.timer >/dev/null 2>&1; then echo "fstrim.timer Status: Enabled (Active: $(systemctl is-active fstrim.timer))"; else echo "fstrim.timer Status: Disabled"; fi; print_message info "--- End System Information ---"; }
view_applied_optimizations() { print_message info "--- Log File ($LOG_FILE) ---"; if [[ -f "$LOG_FILE" ]]; then cat "$LOG_FILE"; else print_message warning "Log file not found."; fi; print_message info "--- End Log File ---"; }
revert_optimizations() { print_message warning "--- Revert Optimizations (Very Limited Function) ---"; print_message warning "${COLOR_BOLD_RED}NOT Reverted:${COLOR_YELLOW} Updates, Packages (Fonts, Conda, Chrome, Papirus, Mesa-git etc.), Firmware, Firewall,"; print_message warning "Gsettings, Sleep mask, Env vars, ZRAM, Chrome tweaks, DNF conf."; print_message warning "${COLOR_YELLOW}Hints:${COLOR_WHITE} Mesa-git: Disable COPR & 'sudo dnf distro-sync'. Gsettings: 'gsettings reset ...'."; if ! ask_confirmation "Proceed with reverting basic settings?"; then return 1; fi; local revert_ok=1; local current_user=${SUDO_USER:-$(whoami)}; local fish_path=$(which fish 2>/dev/null); if [[ -n "$fish_path" ]]; then local current_shell=$(getent passwd "$current_user" | cut -d: -f7); if [[ "$current_shell" == "$fish_path" ]]; then print_message info "Reverting shell to /bin/bash..."; if ! sudo usermod -s /bin/bash "$current_user"; then print_message error "Could not revert shell."; log_action "FishShellRevertFailed" "Revert" "Failed"; revert_ok=0; else log_action "FishShellReverted" "Revert"; fi; fi; fi; local sysctl_conf="/etc/sysctl.d/99-network-optimize.conf"; if [[ -f "$sysctl_conf" ]]; then print_message info "Removing network sysctl..."; if ! sudo rm -f "$sysctl_conf"; then print_message error "Could not remove $sysctl_conf."; log_action "NetworkSysctlRemoveFailed" "Revert" "Failed"; revert_ok=0; else sudo sysctl --system >/dev/null 2>&1; log_action "NetworkSysctlRemoved" "Revert"; fi; fi; local nm_conf_file="/etc/NetworkManager/conf.d/99-custom-dns.conf"; if [[ -f "$nm_conf_file" ]]; then print_message info "Removing custom DNS config..."; if ! sudo rm -f "$nm_conf_file"; then print_message error "Could not remove $nm_conf_file."; log_action "DNSConfigRemoveFailed" "Revert" "Failed"; revert_ok=0; else sudo systemctl reload NetworkManager >/dev/null 2>&1; log_action "DNSConfigRemoved" "Revert"; fi; fi; if systemctl is-enabled fstrim.timer > /dev/null 2>&1; then print_message info "Disabling fstrim.timer..."; if ! sudo systemctl disable --now fstrim.timer >/dev/null 2>&1; then print_message error "Could not disable fstrim.timer."; log_action "FstrimTimerDisableFailed" "Revert" "Failed"; revert_ok=0; else log_action "FstrimTimerDisabled" "Revert"; fi; fi; if systemctl is-enabled preload.service > /dev/null 2>&1; then print_message info "Disabling Preload service..."; if ! sudo systemctl disable --now preload.service >/dev/null 2>&1; then print_message error "Could not disable Preload."; log_action "PreloadDisableFailed" "Revert" "Failed"; revert_ok=0; else log_action "PreloadDisabled" "Revert"; fi; fi; if [[ $revert_ok -eq 1 ]]; then print_message success "Attempt to revert basic settings completed."; else print_message error "Errors occurred during revert attempt."; fi; return $revert_ok; }
show_menu() { clear; print_header "Fedora Optimization Suite v7.4"; print_section_header "Basic Setup & Updates"; print_menu_item "1" "System Update & Essent. Tools"; print_menu_item "2" "RPM Fusion Repositories"; print_menu_item "3" "Multimedia Codecs (Audio/Video/HEIC)"; print_menu_item "4" "Printer Support & Quality Info"; print_menu_item "8" "Update Drivers & Firmware"; print_menu_item "9" "Install/Check GPU Drivers"; print_separator; print_section_header "Performance & Optimization"; print_menu_item "6" "SSD Optimization (TRIM Timer)"; print_menu_item "7" "Network Optimization (BBR+fq_codel)"; print_menu_item "10" "DNS Optimization (Cloudflare/Google)"; print_menu_item "13" "Optimize Firewall (Basic)"; print_menu_item "24" "Enable ZRAM (Faster Swap)"; print_menu_item "28" "Increase DNF Parallel Downloads (6)"; print_separator; print_section_header "Desktop & Application Behavior"; print_menu_item "5" "HDR Info & Wayland Check"; print_menu_item "14" "GNOME Basic Optimization (Tweaks)"; print_menu_item "20" "Configure GNOME Idle Delay (Screen Off)"; print_menu_item "22" "Force Wayland for Apps (Firefox/Qt)"; print_menu_item "29" "Increase Mutter Check-Alive Timeout"; print_menu_item "30" "Enable Wayland Fractional Scaling"; print_separator; print_section_header "Advanced Graphics/System Tweaks"; print_menu_item "23" "Apply AMD GPU Perf Tweaks (ACO)"; print_menu_item "31" "Install Mesa-git Vulkan Drivers (${COLOR_BOLD_RED}RISKY!${COLOR_SECTION_HEADER})"; print_menu_item "32" "Info: Patched Components (VRR, etc.)"; print_separator; print_section_header "Appearance & Extra Software"; print_menu_item "11" "Install Extra Packages (preload, etc)"; print_menu_item "15" "Install Fonts (MS Core, Noto, etc.)"; print_menu_item "17" "Install Papirus Icons & Orange Folders"; print_menu_item "27" "Manage Google Chrome (Install/Optimize)"; print_menu_item "12" "Set Fish Shell as Default"; print_menu_item "16" "Install Conda (Miniconda)"; print_separator; print_section_header "System Behavior & Risky Actions"; print_menu_item "18" "Disable PC Speaker Beep"; print_menu_item "19" "Disable Sleep/Suspend (${COLOR_BOLD_RED}RISKY!${COLOR_SECTION_HEADER})"; print_menu_item "21" "Grant Broad Flatpak Permissions (${COLOR_BOLD_RED}EXTREME RISK!${COLOR_SECTION_HEADER})"; print_separator; print_section_header "Maintenance & Script Actions"; print_menu_item "25" "Attempt DNF/RPM Repair"; print_menu_item "26" "Clean System (Cache, Kernels, etc.)"; print_menu_item "A" "Apply Safe Optimizations"; print_menu_item "E" "Apply EVERYTHING (${COLOR_BOLD_RED}INCL. RISK!${COLOR_SECTION_HEADER})"; print_menu_item "S" "Show System Information"; print_menu_item "L" "View Log File ($LOG_FILE)"; print_menu_item "R" "Revert Optimizations (Very Limited!)"; print_menu_item "Q" "Quit Script"; print_footer; echo -e "${COLOR_PROMPT}Enter your choice: ${COLOR_RESET}\c"; read choice; }


# --- Main Logic ---
check_root
while true; do
    show_menu

    last_exit_code=0 # Reset before executing choice

    case "$choice" in
        # Map choices to functions (check numbering!)
        1) update_system; last_exit_code=$? ;; 2) enable_rpmfusion; last_exit_code=$? ;; 3) install_codecs; last_exit_code=$? ;; 4) install_printer_support; last_exit_code=$? ;;
        5) check_hdr_support; last_exit_code=$? ;; 6) optimize_ssd; last_exit_code=$? ;; 7) optimize_network; last_exit_code=$? ;; 8) update_drivers_firmware; last_exit_code=$? ;;
        9) install_gpu_drivers; last_exit_code=$? ;; 10) optimize_dns; last_exit_code=$? ;; 11) install_extra_packages; last_exit_code=$? ;; 12) set_fish_shell; last_exit_code=$? ;;
        13) optimize_firewall; last_exit_code=$? ;; 14) optimize_gnome_desktop; last_exit_code=$? ;; 15) install_fonts; last_exit_code=$? ;; 16) install_conda; last_exit_code=$? ;;
        17) install_papirus_icons; last_exit_code=$? ;; 18) disable_pc_beep; last_exit_code=$? ;; 19) disable_sleep_suspend; last_exit_code=$? ;; 20) configure_gnome_idle; last_exit_code=$? ;;
        21) grant_flatpak_permissions; last_exit_code=$? ;; 22) force_wayland_apps; last_exit_code=$? ;; 23) apply_amd_tweaks; last_exit_code=$? ;; 24) enable_zram; last_exit_code=$? ;;
        25) repair_dnf_rpm; last_exit_code=$? ;; 26) cleanup_system; last_exit_code=$? ;; 27) manage_google_chrome; last_exit_code=$? ;;
        28) configure_dnf_downloads; last_exit_code=$? ;; 29) configure_mutter_timeout; last_exit_code=$? ;; 30) enable_wayland_fractional_scaling; last_exit_code=$? ;;
        31) install_mesa_git; last_exit_code=$? ;; 32) info_patched_components; last_exit_code=$? ;;

        [aA]) # Apply Safe Optimizations
            print_message info "Applying a set of relatively safe optimizations..."
            local safe_steps=(1 2 3 4 6 7 8 9 10 11 13 14 15 17 18 20 22 23 24 26 27 28 29 30)
            local step_list=$(IFS=,; echo "${safe_steps[*]}")
            print_message info "(Steps: $step_list)"
            print_message warning "(Skipping: 5(Info), 12(Fish), 16(Conda), 19(Sleep!), 21(Flatpak!!), 25(Repair), 31(Mesa-Git!), 32(Info Patches))"
            if ask_confirmation "Are you sure you want to apply these safe optimizations?"; then
                overall_success=1
                for step in "${safe_steps[@]}"; do
                    print_message info "--- [A] Executing Step $step ---"
                    step_func_exit_code=0
                    case "$step" in
                         1) update_system ;; 2) enable_rpmfusion ;; 3) install_codecs ;; 4) install_printer_support ;;
                         6) optimize_ssd ;; 7) optimize_network ;; 8) update_drivers_firmware ;; 9) install_gpu_drivers ;;
                         10) optimize_dns ;; 11) install_extra_packages ;; 13) optimize_firewall ;; 14) optimize_gnome_desktop ;;
                         15) install_fonts ;; 17) install_papirus_icons ;; 18) disable_pc_beep ;; 20) configure_gnome_idle ;;
                         22) force_wayland_apps ;; 23) apply_amd_tweaks ;; 24) enable_zram ;; 26) cleanup_system ;;
                         27) manage_google_chrome ;; 28) configure_dnf_downloads ;; 29) configure_mutter_timeout ;; 30) enable_wayland_fractional_scaling ;;
                         *) print_message warning "Unknown step $step in safe list."; continue ;;
                    esac
                    step_func_exit_code=$?
                    if [[ "$step_func_exit_code" -ne 0 ]]; then
                         last_log_line=$(tail -n 1 "$LOG_FILE")
                         if [[ "$step_func_exit_code" -eq 1 && "$last_log_line" == *"Action cancelled"* ]]; then
                              print_message warning "Step $step cancelled by user. Stopping bulk action."
                         else
                             print_message error "!!! Step $step failed (Exit Code: $step_func_exit_code). Stopping bulk action. !!!"
                         fi
                        overall_success=0
                        break
                    fi
                     print_message info "--- Step $step completed ---"
                     sleep 0.5
                done
                if [[ "$overall_success" -eq 1 ]]; then print_message success "All safe optimizations completed successfully!"; print_message warning "A REBOOT may be required."; else print_message error "One or more steps failed/cancelled. Check log: $LOG_FILE"; fi
            else print_message warning "Bulk action (Safe) cancelled."; fi
            last_exit_code=0 # Reset exit code for menu pause logic
             ;; # End [aA]

        [eE]) # Apply EVERYTHING (incl. Risk)
             print_message error "*** APPLY EVERYTHING (INCLUDING RISKY OPTIONS) ***"
             local all_steps=(1 2 3 4 6 7 8 9 10 11 13 14 15 17 18 19 20 21 22 23 24 26 27 28 29 30 31)
             local step_list=$(IFS=,; echo "${all_steps[*]}")
             echo -e "${COLOR_BOLD_RED}WARNING:${COLOR_YELLOW} Includes risky actions like Disable Sleep(19), Flatpak Perms(21), Mesa-git(31)! Be ABSOLUTELY SURE!"
             print_message info "(Steps to be executed: $step_list)"
             echo -e "${COLOR_PROMPT}Type exactly ${COLOR_BOLD_WHITE}YES I ACCEPT ALL RISKS${COLOR_RESET} to continue:"
             read -p ": " confirmation_text_e
             if [[ "$confirmation_text_e" != "YES I ACCEPT ALL RISKS" ]]; then print_message warning "Confirmation incorrect. 'Apply EVERYTHING' cancelled."; last_exit_code=1; else
                 print_message info "Final check: Proceed with ALL steps?"
                 if ask_confirmation; then
                    overall_success_e=1
                    print_message info "Starting execution of ALL selected steps..."
                    sleep 1
                    for step in "${all_steps[@]}"; do
                        print_message info "--- [E] Executing Step $step ---"
                        step_func_exit_code_e=0
                        case "$step" in
                             1) update_system ;; 2) enable_rpmfusion ;; 3) install_codecs ;; 4) install_printer_support ;;
                             6) optimize_ssd ;; 7) optimize_network ;; 8) update_drivers_firmware ;; 9) install_gpu_drivers ;;
                             10) optimize_dns ;; 11) install_extra_packages ;; 13) optimize_firewall ;; 14) optimize_gnome_desktop ;;
                             15) install_fonts ;; 17) install_papirus_icons ;; 18) disable_pc_beep ;; 19) disable_sleep_suspend ;;
                             20) configure_gnome_idle ;; 21) grant_flatpak_permissions ;; 22) force_wayland_apps ;; 23) apply_amd_tweaks ;;
                             24) enable_zram ;; 26) cleanup_system ;; 27) manage_google_chrome ;;
                             28) configure_dnf_downloads ;; 29) configure_mutter_timeout ;; 30) enable_wayland_fractional_scaling ;; 31) install_mesa_git ;;
                             *) print_message warning "Unknown step $step in 'Apply EVERYTHING' list."; continue ;;
                        esac
                        step_func_exit_code_e=$?
                        if [[ "$step_func_exit_code_e" -ne 0 ]]; then
                             last_log_line=$(tail -n 1 "$LOG_FILE")
                             if [[ "$step_func_exit_code_e" -eq 1 && "$last_log_line" == *"Action cancelled"* ]]; then
                                 print_message warning "Step $step skipped/cancelled by user. Continuing..."
                             else
                                 print_message error "!!! Step $step failed (Exit Code: $step_func_exit_code_e). Stopping 'Apply EVERYTHING'. !!!"
                                 overall_success_e=0; break;
                             fi
                        else
                             print_message info "--- Step $step completed ---"
                             sleep 0.5
                        fi
                    done
                    if [[ "$overall_success_e" -eq 1 ]]; then print_message success "'Apply EVERYTHING' completed (with possible cancellations)."; print_message warning "${COLOR_BOLD_RED}REBOOT is STRONGLY recommended!${COLOR_RESET}"; else print_message error "One or more steps failed during 'Apply EVERYTHING'. Check log: $LOG_FILE"; fi
                else print_message warning "Bulk action (Everything) cancelled."; last_exit_code=1; fi
             fi
             ;; # End [eE]

        [sS]) show_system_info; last_exit_code=$? ;;
        [lL]) view_applied_optimizations; last_exit_code=$? ;;
        [rR]) revert_optimizations; last_exit_code=$? ;;
        [qQ]) print_message info "Exiting script."; print_footer; exit 0 ;;
        *) print_message error "Invalid choice '$choice'."; last_exit_code=1 ;;
    esac

    # Pause after most actions, except invalid choice or cancellation (exit code != 0)
    # Also skip pause after bulk actions which have their own prompt
    if [[ "$last_exit_code" -eq 0 && ! "$choice" =~ ^[aAeE]$ ]] ; then
        echo -e "\n${COLOR_PROMPT}Press Enter to return to the menu...${COLOR_RESET}"
        read -r
    elif [[ "$last_exit_code" -ne 0 && ! "$choice" =~ ^[aAeE]$ ]] ; then
         # Wait a bit after error or cancellation
         sleep 2
    fi
    # No extra pause needed after bulk actions (a/A/e/E)

done